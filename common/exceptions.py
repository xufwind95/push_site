import logging

from rest_framework.views import exception_handler
from rest_framework.response import Response

logger = logging.getLogger()


def core_exception_handler(exc, context):
    # If an exception is thrown that we don't explicitly handle here, we want
    # to delegate to the default exception handler offered by DRF. If we do
    # handle this exception type, we will still want access to the response
    # generated by DRF, so we get that response up front.
    response = exception_handler(exc, context)
    handlers = {
        'NotEnoughMoneyValidationError': _handle_need_coin_error,
        'NotFound': _handle_not_found_error,
        'ValidationError': _handle_generic_error,
        'ValueError': _handler_value_err,
        'DoesNotExist': _handler_does_not_exist,
        'AuthenticationFailed': _handle_auth_error,
        'NotAuthenticated': _handle_auth_error
    }
    # This is how we identify the type of the current exception. We will use
    # this in a moment to see whether we should handle this exception or let
    # Django REST Framework do it's thing.
    exception_class = exc.__class__.__name__

    if exception_class in handlers:
        # If this exception is one that we can handle, handle it. Otherwise,
        # return the response generated earlier by the default exception
        # handler.
        return handlers[exception_class](exc, context, response)

    return response


def _handler_value_err(exc, context, response):
    data = {
        'msg': 'user input err: the data you post is not valid',
        'data': '',
        'code': -1,
    }
    if hasattr(response, 'data') and len(response.data) >= 0:
        key, value = response.data.popitem()
        data['msg'] = "{0}, {1}".format(key, value[0])
    if not response:
        response = Response(data, status=400)
    else:
        response.data = data
    return response


def _handler_does_not_exist(exc, context, response):
    """when this error happened,the response may not exists, so there must be a check"""
    data = {
        'msg': 'user input err: the data you required does not exist',
        'data': '',
        'code': -4,
    }
    if hasattr(response, 'data') and len(response.data) >= 0:
        key, value = response.data.popitem()
        data['msg'] = "{0}, {1}".format(key, value[0])
    if not response:
        response = Response(data, status=400)
    else:
        response.data = data
    return response


def _handle_generic_error(exc, context, response):
    # This is about the most straightforward exception handler we can create.
    # We take the response generated by DRF and wrap it in the `errors` key.
    try:
        error_message = exc.detail
        error_message = error_message[0]
    except Exception:
        error_message = ''
    data = {
        'msg': 'user input error:{}'.format(error_message),
        'code': -1,
    }
    try:
        if hasattr(response, 'data') and len(response.data) >= 0:
            key, value = response.data.popitem()
            data['msg'] = "{0}, {1}".format(key, value[0])
    except AttributeError:
        data['data'] = ''
    response.data = data
    return response


def _handle_not_found_error(exc, context, response):
    view = context.get('view', None)

    if view and hasattr(view, 'queryset') and view.queryset is not None:
        error_key = view.queryset.model._meta.verbose_name

        response.data = {
            'errors': {
                error_key: response.data['detail']
            }
        }

    else:
        response = _handle_generic_error(exc, context, response)

    return response


def _handle_auth_error(exc, context, response):
    # This is about the most straightforward exception handler we can create.
    # We take the response generated by DRF and wrap it in the `errors` key.

    data = {
        'msg': response.data['detail'],
        'code': -2,
    }

    response.data = data
    response.status_code = 401
    return response


def _handle_need_coin_error(exc, context, response):
    # This is about the most straightforward exception handler we can create.
    # We take the response generated by DRF and wrap it in the `errors` key.

    data = {
        'msg': 'need more coin',
        'code': -5,
        'data': ''
    }

    response.data = data
    return response
